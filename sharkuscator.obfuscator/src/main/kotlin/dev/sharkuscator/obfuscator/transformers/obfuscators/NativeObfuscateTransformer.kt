package dev.sharkuscator.obfuscator.transformers.obfuscators

import dev.sharkuscator.commons.extensions.hasVisibleAnnotationContaining
import dev.sharkuscator.commons.extensions.isAutoGenerated
import dev.sharkuscator.commons.extensions.isDeclaredAsInterface
import dev.sharkuscator.commons.extensions.isSpongeMixin
import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.configuration.transformers.TransformerConfiguration
import dev.sharkuscator.obfuscator.events.ObfuscatorEvents
import dev.sharkuscator.obfuscator.transformers.BaseTransformer
import dev.sharkuscator.obfuscator.transformers.TransformerPriority
import dev.sharkuscator.obfuscator.transformers.TransformerStrength
import meteordevelopment.orbit.EventHandler
import java.nio.file.Files
import java.nio.file.Paths
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.absolutePathString
import kotlin.io.path.appendText
import kotlin.io.path.deleteRecursively

object NativeObfuscateTransformer : BaseTransformer<TransformerConfiguration>("NativeObfuscate", TransformerConfiguration::class.java) {
    private val nativeObfuscatorToolPath = Paths.get("./thirdparty", "native-obfuscator.jar")

    @EventHandler
    @Suppress("unused")
    @OptIn(ExperimentalPathApi::class)
    private fun onFinalization(event: ObfuscatorEvents.FinalizationEvent) {
        if (!Files.exists(nativeObfuscatorToolPath)) {
            ObfuscatorServices.sharkLogger.error("native-obfuscator.jar does not exist!")
            return
        }

//        if (event.context.isInputRecognizedAsMinecraftMod) {
//            ObfuscatorServices.sharkLogger.error("Minecraft mod not supported by NativeObfuscateTransformer")
//            return
//        }

        ObfuscatorServices.sharkLogger.info("Running Native obfuscator...")
        val exclusionsFilePath = Files.createTempFile("native-obfuscator-exclusions", ".txt")
//        exclusionsFilePath.toFile().deleteOnExit()

        exclusionsFilePath.appendText(configuration.exclusions.joinToString("\n") { it.replace(".", "/") })
        for (classNode in event.context.downloadedLibrary.classNodes.filter { !it.isAutoGenerated() }) {
            if (classNode.isSpongeMixin() || classNode.isDeclaredAsInterface() || classNode.hasVisibleAnnotationContaining("config")) {
                exclusionsFilePath.appendText("\n$ObfuscatorServices.symbolRemapper.symbolMappings[classNode.name] ?: classNode.name")
                continue
            }

//            for (methodNode in classNode.methods.filter { it.isMixinAccessor() || it.hasVisibleAnnotationContaining("oneconfig") }) {
//                val oklahoma = ObfuscatorServices.symbolRemapper.symbolMappings[classNode.name] ?: classNode.name
//                exclusionsFilePath.appendText("\n$oklahoma#${methodNode.name}${methodNode.desc}")
//                continue
//            }
        }

        val outputNativeLibDirPath = Paths.get("./native_library")
        if (Files.exists(outputNativeLibDirPath)) {
            outputNativeLibDirPath.deleteRecursively()
        }

        val nativeObfuscatorProcessBuilder = ProcessBuilder("java", "-jar", nativeObfuscatorToolPath.toString(), event.outputJarFile.name, outputNativeLibDirPath.toString(), "-p", "std_java", "-b", exclusionsFilePath.absolutePathString())
        ObfuscatorServices.sharkLogger.info("Commandline: ${nativeObfuscatorProcessBuilder.command().joinToString(" ")}")

//        val nativeObfuscatorProcess = nativeObfuscatorProcessBuilder.start()
//        nativeObfuscatorProcess.inputStream.bufferedReader().use { ObfuscatorServices.sharkLogger.info(it.readText()) }
//        nativeObfuscatorProcess.waitFor(1, TimeUnit.MINUTES)
    }

    override fun transformerStrength(): TransformerStrength {
        return TransformerStrength.STRONG
    }

    override fun executionPriority(): Int {
        return TransformerPriority.ONE_HUNDRED
    }
}
