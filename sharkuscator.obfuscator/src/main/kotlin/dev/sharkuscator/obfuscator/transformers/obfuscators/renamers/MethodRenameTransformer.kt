package dev.sharkuscator.obfuscator.transformers.obfuscators.renamers

import dev.sharkuscator.commons.extensions.*
import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.configuration.GsonConfiguration
import dev.sharkuscator.obfuscator.configuration.transformers.RenameConfiguration
import dev.sharkuscator.obfuscator.dictionaries.DictionaryFactory
import dev.sharkuscator.obfuscator.dictionaries.MappingDictionary
import dev.sharkuscator.obfuscator.events.TransformerEvents
import dev.sharkuscator.obfuscator.transformers.BaseTransformer
import dev.sharkuscator.obfuscator.transformers.TransformerPriority
import dev.sharkuscator.obfuscator.transformers.TransformerStrength
import meteordevelopment.orbit.EventHandler
import org.objectweb.asm.tree.ClassNode

object MethodRenameTransformer : BaseTransformer<RenameConfiguration>("MethodRename", RenameConfiguration::class.java) {
    private val disallowedInterfacePatterns = listOf("com.sun.jna.*".toRegex())
    private val classToRemappedDescriptors = mutableMapOf<ClassNode, MutableSet<String>>()
    lateinit var methodMappingDictionary: MappingDictionary<ClassNode>

    override fun initialization(configuration: GsonConfiguration): RenameConfiguration {
        methodMappingDictionary = DictionaryFactory.createDictionary(super.initialization(configuration).dictionary)
        return this.configuration
    }

    @EventHandler
    @Suppress("unused")
    private fun onMethodTransform(event: TransformerEvents.MethodTransformEvent) {
        if (!isEligibleForExecution() || exclusions.excluded(event.nodeObject) || event.nodeObject.isDeclaredNative() || event.nodeObject.shouldSkipTransform()) {
            return
        }

        val targetClassNode = event.nodeObject.classNode
        if (event.obfuscationContext.isRecognizedAsMinecraftMod && (event.nodeObject.isMixinAccessor() || event.nodeObject.name.startsWith("func_"))) {
            return
        }

        if (targetClassNode.isDeclaredAsAnnotation() || ObfuscatorServices.symbolRemapper.symbolMappings.containsKey(event.nodeObject.getQualifiedName())) {
            return
        }

        if (targetClassNode.interfaces.any { className -> disallowedInterfacePatterns.any { it.matches(className) } }) {
            return
        }

        val targetClassDescriptors = classToRemappedDescriptors.computeIfAbsent(targetClassNode) { mutableSetOf() }
//        val currentParameterDescriptor = event.anytypeNode.desc.substringAfter("(").substringBefore(")")

        val methodHierarchyRoot = event.obfuscationContext.hierarchyProvider.getRootMethodNode(event.nodeObject)
        if (methodHierarchyRoot != null) {
            if (event.obfuscationContext.classNodeProvider.isLibraryClass(methodHierarchyRoot.classNode.name) || methodHierarchyRoot.classNode.isAutoGenerated()) {
                return
            }

            val rootOwnerDescriptors = classToRemappedDescriptors.computeIfAbsent(methodHierarchyRoot.classNode) { mutableSetOf() }
            val methodMapping = ObfuscatorServices.symbolRemapper.symbolMappings[methodHierarchyRoot.getQualifiedName()] ?: "${configuration.namePrefix}${methodMappingDictionary.generateNextName(event.nodeObject.classNode)}".also {
                ObfuscatorServices.symbolRemapper.setMapping(methodHierarchyRoot.getQualifiedName(), it)
                rootOwnerDescriptors.add(methodHierarchyRoot.desc)
            }

            ObfuscatorServices.symbolRemapper.setMapping(event.nodeObject.getQualifiedName(), methodMapping)
            targetClassDescriptors.add(event.nodeObject.desc)
        } else {
            val methodMapping = "${configuration.namePrefix}${methodMappingDictionary.generateNextName(event.nodeObject.classNode)}"
            ObfuscatorServices.symbolRemapper.setMapping(event.nodeObject.getQualifiedName(), methodMapping)
            targetClassDescriptors.add(event.nodeObject.desc)
        }
    }

    override fun transformerStrength(): TransformerStrength {
        return TransformerStrength.MODERATE
    }

    override fun executionPriority(): Int {
        return TransformerPriority.TWENTY_FIVE
    }
}
