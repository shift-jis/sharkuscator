package dev.sharkuscator.obfuscator.transformers.obfuscators.renamers

import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.configuration.GsonConfiguration
import dev.sharkuscator.obfuscator.configuration.transformers.RenameConfiguration
import dev.sharkuscator.obfuscator.dictionaries.DictionaryFactory
import dev.sharkuscator.obfuscator.dictionaries.MappingDictionary
import dev.sharkuscator.obfuscator.events.TransformerEvents
import dev.sharkuscator.obfuscator.extensions.getQualifiedName
import dev.sharkuscator.obfuscator.extensions.isAutoGenerated
import dev.sharkuscator.obfuscator.extensions.isDeclaredAsAnnotation
import dev.sharkuscator.obfuscator.extensions.isMixinAccessor
import dev.sharkuscator.obfuscator.extensions.shouldSkipTransform
import dev.sharkuscator.obfuscator.transformers.BaseTransformer
import dev.sharkuscator.obfuscator.transformers.TransformerPriority
import meteordevelopment.orbit.EventHandler
import org.mapleir.asm.ClassNode

object MethodRenameTransformer : BaseTransformer<RenameConfiguration>("MethodRename", RenameConfiguration::class.java) {
    private val badInterfaces = listOf("com.sun.jna.*".toRegex())
    lateinit var dictionary: MappingDictionary<ClassNode>

    override fun initialization(configuration: GsonConfiguration): RenameConfiguration {
        dictionary = DictionaryFactory.createDictionary(super.initialization(configuration).dictionary)
        return this.configuration
    }

    @EventHandler
    @Suppress("unused")
    private fun onMethodTransform(event: TransformerEvents.MethodTransformEvent) {
        if (transformed || exclusions.excluded(event.anytypeNode) || event.anytypeNode.isNative || event.anytypeNode.shouldSkipTransform()) {
            return
        }

        val classNode = event.anytypeNode.owner
        if (event.context.isInputRecognizedAsMinecraftMod && (event.anytypeNode.isMixinAccessor() || event.anytypeNode.name.startsWith("func_"))) {
            return
        }

        if (classNode.isDeclaredAsAnnotation() || ObfuscatorServices.symbolRemapper.symbolMappings.containsKey(event.anytypeNode.getQualifiedName())) {
            return
        }

        if (classNode.node.interfaces.any { className -> badInterfaces.any { it.matches(className) } }) {
            return
        }

        val rootMethodNode = event.context.hierarchyProvider.getRootMethodNode( event.anytypeNode)
        if (rootMethodNode != null) {
            if (event.context.classSource.isLibraryClass(rootMethodNode.owner.name) || rootMethodNode.owner.isAutoGenerated()) {
                return
            }

            val methodMapping = ObfuscatorServices.symbolRemapper.symbolMappings[rootMethodNode.getQualifiedName()] ?: "${configuration.namePrefix}${dictionary.generateNextName(event.anytypeNode.owner)}".also {
                ObfuscatorServices.symbolRemapper.setMapping(rootMethodNode.getQualifiedName(), it)
            }
            ObfuscatorServices.symbolRemapper.setMapping(event.anytypeNode.getQualifiedName(), methodMapping)
        } else {
            val methodMapping = "${configuration.namePrefix}${dictionary.generateNextName(event.anytypeNode.owner)}"
            ObfuscatorServices.symbolRemapper.setMapping(event.anytypeNode.getQualifiedName(), methodMapping)
        }
    }

    override fun getExecutionPriority(): Int {
        return TransformerPriority.TWENTY_FIVE
    }
}
