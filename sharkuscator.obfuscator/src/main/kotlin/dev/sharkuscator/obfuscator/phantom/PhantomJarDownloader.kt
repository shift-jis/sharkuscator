package dev.sharkuscator.obfuscator.phantom

import ch.qos.logback.classic.Level
import com.google.common.io.ByteStreams
import org.clyze.jphantom.JPhantom
import org.clyze.jphantom.Options
import org.clyze.jphantom.Phantoms
import org.clyze.jphantom.access.ClassAccessStateMachine
import org.clyze.jphantom.access.FieldAccessStateMachine
import org.clyze.jphantom.access.MethodAccessStateMachine
import org.clyze.jphantom.constraints.Constraint
import org.mapleir.asm.ClassHelper
import org.mapleir.asm.ClassNode
import org.objectweb.asm.*
import org.topdank.byteengineer.commons.asm.ASMFactory
import org.topdank.byteengineer.commons.data.*
import org.topdank.byteio.`in`.AbstractJarDownloader
import java.net.JarURLConnection
import java.net.URL


class PhantomJarDownloader(private val asmFactory: ASMFactory<ClassNode>, private val jarInfo: JarInfo) : AbstractJarDownloader<ClassNode>(asmFactory) {
    private val isUsingPhantomFactory: Boolean
        get() = asmFactory is PhantomASMFactory

    val generatedClassContent: DataContainer<ClassNode> = JarContents.ClassNodeContainer()

    override fun download() {
        contents = LocateableJarContents(URL(jarInfo.formattedURL()))
        val connection = contents.jarUrls.first().openConnection() as JarURLConnection
        connection.jarFile.entries().iterator().forEach { jarEntry ->
            val byteArray = ByteStreams.toByteArray(connection.jarFile.getInputStream(jarEntry))
            if (jarEntry.name.endsWith(".class")) {
                val classNode = factory.create(byteArray, jarEntry.getName())
                contents.classContents.add(classNode)
            } else {
                contents.resourceContents.add(JarResource(jarEntry.getName(), byteArray))
            }
        }

        if (isUsingPhantomFactory) {
            Options.V().setLogLevel(Level.OFF)
            Options.V().isSoftFail = true
            Options.V().javaVersion = 8

            val uniqueConstraintRepresentations: MutableSet<String> = HashSet()
            ClassAccessStateMachine.v().constraints.removeIf { constraint: Constraint ->
                val wasAlreadySeen = uniqueConstraintRepresentations.contains(constraint.toString())
                uniqueConstraintRepresentations.add(constraint.toString())
                wasAlreadySeen
            }

            val phantomTypeMap: MutableMap<Type, org.objectweb.asm.tree.ClassNode> = HashMap()
            val phantomAsmFactory = factory as PhantomASMFactory

            val jPhantomInstance = JPhantom(phantomTypeMap, phantomAsmFactory.classHierarchy, phantomAsmFactory.classMembers)
            jPhantomInstance.run()

            jPhantomInstance.generated.forEach { (_, byteArray) ->
                val decoratedByteArray = decorateWithAutoGeneratedAnnotation(byteArray)
                val classReader = ClassReader(decoratedByteArray)

                val classNode = org.objectweb.asm.tree.ClassNode()
                classReader.accept(classNode, ClassReader.SKIP_DEBUG or ClassReader.SKIP_FRAMES)

                generatedClassContent.add(ClassHelper.create(classNode))
            }

            MethodAccessStateMachine.refresh()
            FieldAccessStateMachine.refresh()
            ClassAccessStateMachine.refresh()
            Phantoms.refresh()
        }
    }

    private fun decorateWithAutoGeneratedAnnotation(generated: ByteArray): ByteArray {
        val classWriter = ClassWriter(ClassWriter.COMPUTE_FRAMES)

        val classVisitor = object : ClassVisitor(Opcodes.ASM9, classWriter) {
            override fun visitEnd() {
                val annotationVisitor = visitAnnotation("LAutoGenerated;", true)
                annotationVisitor.visit("msg", "Recaf/JPhantom automatically generated this class")
                annotationVisitor.visitEnd()
                super.visitEnd()
            }
        }

        val classReader = ClassReader(generated)
        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG or ClassReader.SKIP_FRAMES)

        return classWriter.toByteArray()
    }
}
