package dev.sharkuscator.obfuscator.hierarchies

import dev.sharkuscator.obfuscator.extensions.getQualifiedName
import dev.sharkuscator.obfuscator.extensions.isAutoGenerated
import org.mapleir.app.service.ApplicationClassSource
import org.mapleir.asm.ClassNode
import org.mapleir.asm.MethodNode

class DefaultHierarchyProvider(private val classSource: ApplicationClassSource) : HierarchyProvider {
    val classChildren: MutableMap<ClassNode, MutableSet<ClassNode>> = mutableMapOf()
    val classParents: MutableMap<ClassNode, MutableSet<ClassNode>> = mutableMapOf()
    private val visitHierarchies: MutableSet<String> = hashSetOf()

    override fun traverseHierarchy(classNode: ClassNode) {
        if (visitHierarchies.add(classNode.name)) {
            if (classNode.node.superName != null) {
                val resolvedSuperNode = classSource.findClass(classNode.node.superName!!)?.node ?: return
                classParents.computeIfAbsent(classNode) { mutableSetOf() }.add(resolvedSuperNode)
                classChildren.computeIfAbsent(resolvedSuperNode) { mutableSetOf() }.add(classNode)
                traverseHierarchy(resolvedSuperNode)
            }

            classNode.node.interfaces.forEach { interfaceName ->
                val resolvedInterfaceNode = classSource.findClass(interfaceName)?.node ?: return
                classParents.computeIfAbsent(classNode) { mutableSetOf() }.add(resolvedInterfaceNode)
                classChildren.computeIfAbsent(resolvedInterfaceNode) { mutableSetOf() }.add(classNode)
                traverseHierarchy(resolvedInterfaceNode)
            }
        }
    }

    override fun getClassParents(classNode: ClassNode): Set<ClassNode> {
        return classParents[classNode] ?: emptySet()
    }

    override fun getClassChildren(classNode: ClassNode): Set<ClassNode> {
        return classChildren[classNode] ?: emptySet()
    }

    override fun getRootMethodNode(methodNode: MethodNode): MethodNode? {
        return getRootMethodNode(methodNode.owner, methodNode)
    }

    private fun getRootMethodNode(classNode: ClassNode, methodNode: MethodNode): MethodNode? {
        if (methodNode.name == "<init>" || methodNode.name == "<clinit>") return null

        for (parentClassNode in getClassParents(classNode)) {
            for (parentMethodNode in parentClassNode.methods) {
                if (methodNode.name == parentMethodNode.name && methodNode.desc == parentMethodNode.desc) {
                    return parentMethodNode
                }

                val originalMethodNode = getRootMethodNode(parentClassNode, methodNode)
                if (originalMethodNode != null) {
                    return originalMethodNode
                }
            }
        }

        return null
    }
}
