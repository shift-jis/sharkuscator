package dev.sharkuscator.obfuscator.assembler

import dev.sharkuscator.obfuscator.ObfuscationContext
import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.events.AssemblerEvents
import dev.sharkuscator.obfuscator.extensions.isAutoGenerated
import org.mapleir.app.service.ClassTree
import org.mapleir.app.service.CompleteResolvingJarDumper
import org.mapleir.asm.ClassNode
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.commons.ClassRemapper
import java.io.File
import java.io.FileOutputStream
import java.util.jar.JarEntry
import java.util.jar.JarOutputStream
import java.util.zip.CRC32
import java.util.zip.Deflater
import java.util.zip.ZipOutputStream
import kotlin.random.Random


class ResolvingDumper(private val obfuscationContext: ObfuscationContext) : CompleteResolvingJarDumper(obfuscationContext.jarContents, obfuscationContext.classSource) {
    private val discoveredPackages = mutableListOf<String>()

    override fun dump(outputJarFile: File) {
        if (outputJarFile.exists() && !outputJarFile.delete()) {
            ObfuscatorServices.sharkLogger.error("Could not delete an already existing destination file")
            return
        }

        JarOutputStream(FileOutputStream(outputJarFile)).use { outputStream ->
            outputStream.setLevel(Deflater.BEST_COMPRESSION)
            bypassZipEntryDuplicateNameCheck(outputStream)
            corruptZipEntryCrc(outputStream)

            obfuscationContext.jarContents.resourceContents.filter { !it.name.endsWith("/") }.forEach {
                discoveredPackages.add(it.name.split("/").dropLast(1).joinToString("/"))
            }

            for (classNode in obfuscationContext.jarContents.classContents.filter { !it.isAutoGenerated() }) {
                dumpClass(outputStream, classNode.name, classNode)
            }

            for (jarResource in obfuscationContext.jarContents.resourceContents) {
                dumpResource(outputStream, jarResource.name, jarResource.data)
            }
        }
    }

    override fun dumpClass(outputStream: JarOutputStream, name: String, classNode: ClassNode): Int {
        val classDumpEvent = AssemblerEvents.ClassDumpEvent(obfuscationContext, classNode)
        ObfuscatorServices.mainEventBus.post(classDumpEvent)
        if (classDumpEvent.isCancelled) {
            return 0
        }

        val originalNode = org.objectweb.asm.tree.ClassNode().apply {
            classDumpEvent.classNode.node.accept(ClassRemapper(this, ObfuscatorServices.symbolRemapper))
        }

        val classEntry = JarEntry("${originalNode.name}.class".let {
            return@let if (!obfuscationContext.exclusions.excluded(classNode) && obfuscationContext.configuration.slashClassEntries) it.plus("/") else it
        })
        outputStream.putNextEntry(classEntry)

        try {
            val classWriter = buildClassWriter(obfuscationContext.classSource.classTree, ClassWriter.COMPUTE_FRAMES or ClassWriter.COMPUTE_MAXS)
            originalNode.accept(classWriter)

            val classWriteEvent = AssemblerEvents.ClassWriteEvent(obfuscationContext, classNode, classWriter.toByteArray())
            if (!obfuscationContext.exclusions.excluded(classNode)) {
                ObfuscatorServices.mainEventBus.post(classWriteEvent)
                if (classWriteEvent.isCancelled) {
                    return 0
                }
            }

            if (originalNode.name.contains("/")) {
                discoveredPackages.add(originalNode.name.split("/").dropLast(1).joinToString("/"))
            }

            outputStream.write(classWriteEvent.classData)
        } catch (exception: Exception) {
            exception.printStackTrace()

            val classWriter = buildClassWriter(obfuscationContext.classSource.classTree, ClassWriter.COMPUTE_MAXS)
            originalNode.accept(classWriter)

            val classWriteEvent = AssemblerEvents.ClassWriteEvent(obfuscationContext, classNode, classWriter.toByteArray())
            if (!obfuscationContext.exclusions.excluded(classNode)) {
                ObfuscatorServices.mainEventBus.post(classWriteEvent)
                if (classWriteEvent.isCancelled) {
                    return 0
                }
            }

            if (originalNode.name.contains("/")) {
                discoveredPackages.add(originalNode.name.split("/").dropLast(1).joinToString("/"))
            }

            outputStream.write(classWriteEvent.classData)
        }

        return 1
    }

    override fun dumpResource(outputStream: JarOutputStream, name: String, bytes: ByteArray): Int {
        if (name.endsWith("/") && !discoveredPackages.contains(name)) {
            return 0
        }

        val resourceWriteEvent = AssemblerEvents.ResourceWriteEvent(obfuscationContext, name, bytes)
        if (!obfuscationContext.exclusions.excluded(name)) {
            ObfuscatorServices.mainEventBus.post(resourceWriteEvent)
            if (resourceWriteEvent.isCancelled) {
                return 0
            }
        }

        val resourceEntry = JarEntry(resourceWriteEvent.name)
        outputStream.putNextEntry(resourceEntry)
        outputStream.write(resourceWriteEvent.resourceData)
        return 1
    }

    override fun buildClassWriter(classTree: ClassTree, flags: Int): ClassWriter {
        return ClassWriter(obfuscationContext.classSource, flags)
    }

    private fun bypassZipEntryDuplicateNameCheck(outputStream: ZipOutputStream) {
        try {
            val namesField = ZipOutputStream::class.java.getDeclaredField("names")
            namesField.isAccessible = true

            val dummyNameSet = object : HashSet<String>() {
                override fun add(element: String) = true
            }
            namesField.set(outputStream, dummyNameSet)
        } catch (exception: NoSuchFieldException) {
            ObfuscatorServices.sharkLogger.warn("Failed to disable JAR entry name cache: 'names' field not found. This may happen on newer Java versions. Duplicate entry names will not be possible.", exception)
        } catch (exception: SecurityException) {
            ObfuscatorServices.sharkLogger.warn("Failed to disable JAR entry name cache due to security restrictions.", exception)
        }
    }

    private fun corruptZipEntryCrc(outputStream: ZipOutputStream) {
        try {
            val crcField = ZipOutputStream::class.java.getDeclaredField("crc")
            crcField.isAccessible = true

            val dummyCrc32 = object : CRC32() {
                override fun update(bytes: ByteArray, offset: Int, length: Int) {
                }

                override fun getValue(): Long {
                    return Random.nextLong(0xFFFFFFFFL)
                }
            }
            crcField.set(outputStream, dummyCrc32)
        } catch (exception: NoSuchFieldException) {
            ObfuscatorServices.sharkLogger.warn("Failed to inject CRC corrupter: 'crc' field not found. This may happen on newer Java versions.", exception)
        } catch (exception: SecurityException) {
            ObfuscatorServices.sharkLogger.warn("Failed to inject CRC corrupter due to security restrictions.", exception)
        }
    }
}
