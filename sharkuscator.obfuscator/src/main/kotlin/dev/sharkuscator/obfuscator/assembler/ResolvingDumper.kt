package dev.sharkuscator.obfuscator.assembler

import dev.sharkuscator.obfuscator.ObfuscationContext
import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.events.AssemblerEvents
import dev.sharkuscator.obfuscator.extensions.isAutoGenerated
import org.mapleir.app.service.ClassTree
import org.mapleir.app.service.CompleteResolvingJarDumper
import org.mapleir.asm.ClassNode
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.commons.ClassRemapper
import java.io.File
import java.io.FileOutputStream
import java.util.jar.JarEntry
import java.util.jar.JarOutputStream


class ResolvingDumper(private val context: ObfuscationContext) : CompleteResolvingJarDumper(context.jarContents, context.classSource) {
    private val discoveredPackages = mutableListOf<String>()

    override fun dump(outputJarFile: File) {
        if (outputJarFile.exists() && !outputJarFile.delete()) {
            ObfuscatorServices.sharkLogger.error("Could not delete an already existing destination file")
            return
        }

        JarOutputStream(FileOutputStream(outputJarFile)).use { outputStream ->
            context.jarContents.resourceContents.filter { !it.name.endsWith("/") }.forEach {
                discoveredPackages.add(it.name.split("/").dropLast(1).joinToString("/"))
            }

            for (classNode in context.jarContents.classContents.filter { !it.isAutoGenerated() }) {
                dumpClass(outputStream, classNode.name, classNode)
            }

            for (jarResource in context.jarContents.resourceContents) {
                dumpResource(outputStream, jarResource.name, jarResource.data)
            }
        }
    }

    override fun dumpClass(outputStream: JarOutputStream, name: String, classNode: ClassNode): Int {
        val classDumpEvent = AssemblerEvents.ClassDumpEvent(context, classNode)
        ObfuscatorServices.mainEventBus.post(classDumpEvent)
        if (classDumpEvent.isCancelled) {
            return 0
        }

        val originalNode = org.objectweb.asm.tree.ClassNode().apply {
            classDumpEvent.classNode.node.accept(ClassRemapper(this, ObfuscatorServices.symbolRemapper))
        }

        val classEntry = JarEntry("${originalNode.name}.class".let {
            return@let if (!context.exclusions.excluded(classNode) && context.configuration.slashClassEntries) it.plus("/") else it
        })
        outputStream.putNextEntry(classEntry)

        try {
            val classWriter = buildClassWriter(context.classSource.classTree, ClassWriter.COMPUTE_FRAMES)
            originalNode.accept(classWriter)

            val classWriteEvent = AssemblerEvents.ClassWriteEvent(context, classNode, classWriter.toByteArray())
            if (!context.exclusions.excluded(classNode)) {
                ObfuscatorServices.mainEventBus.post(classWriteEvent)
                if (classWriteEvent.isCancelled) {
                    return 0
                }
            }

            if (originalNode.name.contains("/")) {
                discoveredPackages.add(originalNode.name.split("/").dropLast(1).joinToString("/"))
            }

            outputStream.write(classWriteEvent.classData)
        } catch (exception: Exception) {
            exception.printStackTrace()

            val classWriter = buildClassWriter(context.classSource.classTree, ClassWriter.COMPUTE_MAXS)
            originalNode.accept(classWriter)

            val classWriteEvent = AssemblerEvents.ClassWriteEvent(context, classNode, classWriter.toByteArray())
            if (!context.exclusions.excluded(classNode)) {
                ObfuscatorServices.mainEventBus.post(classWriteEvent)
                if (classWriteEvent.isCancelled) {
                    return 0
                }
            }

            if (originalNode.name.contains("/")) {
                discoveredPackages.add(originalNode.name.split("/").dropLast(1).joinToString("/"))
            }

            outputStream.write(classWriteEvent.classData)
        }

        return 1
    }

    override fun dumpResource(outputStream: JarOutputStream, name: String, bytes: ByteArray): Int {
        if (name.endsWith("/") && !discoveredPackages.contains(name)) {
            return 0
        }

        val resourceWriteEvent = AssemblerEvents.ResourceWriteEvent(context, name, bytes)
        if (!context.exclusions.excluded(name)) {
            ObfuscatorServices.mainEventBus.post(resourceWriteEvent)
            if (resourceWriteEvent.isCancelled) {
                return 0
            }
        }

        val resourceEntry = JarEntry(resourceWriteEvent.name)
        outputStream.putNextEntry(resourceEntry)
        outputStream.write(resourceWriteEvent.resourceData)
        return 1
    }

    override fun buildClassWriter(classTree: ClassTree, flags: Int): ClassWriter {
        return ClassWriter(context.classSource, flags)
    }
}
