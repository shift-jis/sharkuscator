package dev.sharkuscator.obfuscator.extensions

import dev.sharkuscator.obfuscator.utilities.BytecodeUtils
import org.mapleir.asm.ClassNode
import org.mapleir.asm.FieldNode
import org.mapleir.asm.MethodNode
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.InsnNode

fun ClassNode.getQualifiedName(): String = "${node.name}.class"

fun ClassNode.isAnonymousClass(): Boolean = node.name.contains("$")

fun ClassNode.isDeclaredAsInterface(): Boolean = (node.access and Opcodes.ACC_INTERFACE) != 0

fun ClassNode.isDeclaredAsAnnotation(): Boolean = (node.access and Opcodes.ACC_ANNOTATION) != 0

fun ClassNode.isDeclaredAsAbstract(): Boolean = (node.access and Opcodes.ACC_ABSTRACT) != 0

fun ClassNode.containsMainMethod(): Boolean = methods.any { it.hasMainSignature() }

fun ClassNode.isSpongeMixin(): Boolean = node.invisibleAnnotations?.any { it.desc == "Lorg/spongepowered/asm/mixin/Mixin;" } == true

fun ClassNode.isAutoGenerated(): Boolean = node.visibleAnnotations?.any { it.desc == "LAutoGenerated;" } == true

fun ClassNode.isNestedClass(): Boolean = node.outerClass != null && node.outerClass.isNotEmpty()

fun ClassNode.shouldSkipTransform(): Boolean {
    return isDeclaredAsAnnotation() || isDeclaredAsInterface() || isAutoGenerated() || isSpongeMixin() || isAnonymousClass() || isEnum
}

fun ClassNode.getOrCreateStaticInitializer(): MethodNode {
    return methods.find { it.isStaticInitializer() } ?: addNewStaticInitializer()
}

fun ClassNode.addNewStaticInitializer(): MethodNode {
    val staticInitializer = BytecodeUtils.createMethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V").apply {
        instructions = BytecodeUtils.buildInstructionList(InsnNode(Opcodes.RETURN))
    }
    return MethodNode(staticInitializer, this).also {
        this.addMethod(it)
    }
}

fun ClassNode.addField(fieldNode: org.objectweb.asm.tree.FieldNode) {
    addField(FieldNode(fieldNode, this))
}

fun ClassNode.addField(fieldNode: FieldNode) {
    fields.add(fieldNode)
    node.fields.add(fieldNode.node)
}
