package dev.sharkuscator.obfuscator.utilities

import dev.sharkuscator.commons.extensions.isAutoGenerated
import dev.sharkuscator.commons.serializers.BytecodeSerializer
import dev.sharkuscator.obfuscator.ObfuscationContext
import dev.sharkuscator.obfuscator.ObfuscatorServices
import dev.sharkuscator.obfuscator.events.AssemblerEvents
import org.objectweb.asm.commons.ClassRemapper
import org.objectweb.asm.tree.ClassNode
import java.io.File
import java.io.FileOutputStream
import java.util.jar.JarEntry
import java.util.jar.JarOutputStream
import java.util.zip.CRC32
import java.util.zip.Deflater
import java.util.zip.ZipOutputStream
import kotlin.random.Random

class ResolvingJarAssembler(private val obfuscationContext: ObfuscationContext, private val bytecodeSerializer: BytecodeSerializer<ClassNode>) {
    private val discoveredPackages = mutableListOf<String>()

    fun writeToJarFile(outputJarFile: File) {
        if (outputJarFile.exists() && !outputJarFile.delete()) {
            ObfuscatorServices.sharkLogger.error("Could not delete an already existing destination file")
            return
        }

        JarOutputStream(FileOutputStream(outputJarFile)).use { outputStream ->
            outputStream.setLevel(Deflater.BEST_COMPRESSION)
//            bypassZipEntryDuplicateNameCheck(outputStream)
//            corruptZipEntryCrc(outputStream)

            obfuscationContext.downloadedLibrary.resources.filter { !it.first.endsWith("/") }.forEach {
                discoveredPackages.add(it.first.split("/").dropLast(1).joinToString("/"))
            }

            for (classNode in obfuscationContext.downloadedLibrary.classNodes.filter { !it.isAutoGenerated() }) {
                writeClassNode(outputStream, classNode)
            }

            for (jarResource in obfuscationContext.downloadedLibrary.resources) {
                writeResource(outputStream, jarResource.first, jarResource.second)
            }
        }
    }

    fun writeClassNode(outputStream: JarOutputStream, classNode: ClassNode) {
        val remappedClassNode = ClassNode().apply { classNode.accept(ClassRemapper(this, ObfuscatorServices.symbolRemapper)) }
        outputStream.putNextEntry(JarEntry("${remappedClassNode.name}.class".let {
            val shouldAddSlash = !obfuscationContext.exclusions.excluded(classNode) && obfuscationContext.configuration.slashClassEntries
            return@let if (shouldAddSlash) it.plus("/") else it
        }))

        try {
            val classWriteEvent = AssemblerEvents.ClassWriteEvent(obfuscationContext, classNode, bytecodeSerializer.serialize(remappedClassNode))
            if (!obfuscationContext.exclusions.excluded(classNode)) {
                ObfuscatorServices.mainEventBus.post(classWriteEvent)
                if (classWriteEvent.isCancelled) {
                    return
                }
            }

            if (remappedClassNode.name.contains("/")) {
                discoveredPackages.add(remappedClassNode.name.split("/").dropLast(1).joinToString("/"))
            }

            outputStream.write(classWriteEvent.classData)
        } catch (exception: Exception) {
            throw IllegalStateException("Error while writing $remappedClassNode", exception)
        }
    }

    fun writeResource(outputStream: JarOutputStream, name: String, byteArray: ByteArray) {
        if (name.endsWith("/") && !discoveredPackages.contains(name)) {
            return
        }

        val resourceWriteEvent = AssemblerEvents.ResourceWriteEvent(obfuscationContext, name, byteArray)
        if (!obfuscationContext.exclusions.excluded(name)) {
            ObfuscatorServices.mainEventBus.post(resourceWriteEvent)
            if (resourceWriteEvent.isCancelled) {
                return
            }
        }

        outputStream.putNextEntry(JarEntry(resourceWriteEvent.name))
        outputStream.write(resourceWriteEvent.resourceData)
    }

    private fun bypassZipEntryDuplicateNameCheck(outputStream: ZipOutputStream) {
        try {
            val namesField = ZipOutputStream::class.java.getDeclaredField("names")
            namesField.isAccessible = true

            val dummyNameSet = object : HashSet<String>() {
                override fun add(element: String) = true
            }
            namesField.set(outputStream, dummyNameSet)
        } catch (exception: NoSuchFieldException) {
            ObfuscatorServices.sharkLogger.warn("Failed to disable JAR entry name cache: 'names' field not found. This may happen on newer Java versions. Duplicate entry names will not be possible.", exception)
        } catch (exception: SecurityException) {
            ObfuscatorServices.sharkLogger.warn("Failed to disable JAR entry name cache due to security restrictions.", exception)
        }
    }

    private fun corruptZipEntryCrc(outputStream: ZipOutputStream) {
        try {
            val crcField = ZipOutputStream::class.java.getDeclaredField("crc")
            crcField.isAccessible = true

            val dummyCrc32 = object : CRC32() {
                override fun update(bytes: ByteArray, offset: Int, length: Int) {
                }

                override fun getValue(): Long {
                    return Random.nextLong(0xFFFFFFFFL)
                }
            }
            crcField.set(outputStream, dummyCrc32)
        } catch (exception: NoSuchFieldException) {
            ObfuscatorServices.sharkLogger.warn("Failed to inject CRC corrupter: 'crc' field not found. This may happen on newer Java versions.", exception)
        } catch (exception: SecurityException) {
            ObfuscatorServices.sharkLogger.warn("Failed to inject CRC corrupter due to security restrictions.", exception)
        }
    }
}