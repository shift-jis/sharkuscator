package dev.sharkuscator.obfuscator

import dev.sharkuscator.obfuscator.assembler.ResolvingDumper
import dev.sharkuscator.obfuscator.configuration.GsonConfiguration
import dev.sharkuscator.obfuscator.configuration.exclusions.AnnotationExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.ExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.MixedExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.StringExclusionRule
import dev.sharkuscator.obfuscator.events.ObfuscatorEvents
import dev.sharkuscator.obfuscator.events.TransformerEvents
import dev.sharkuscator.obfuscator.extensions.isAutoGenerated
import dev.sharkuscator.obfuscator.hierarchies.DefaultHierarchyProvider
import dev.sharkuscator.obfuscator.hierarchies.HierarchyProvider
import dev.sharkuscator.obfuscator.phantom.PhantomASMFactory
import dev.sharkuscator.obfuscator.phantom.PhantomJarDownloader
import dev.sharkuscator.obfuscator.transformers.obfuscators.DynamicInvokeTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.NativeObfuscateTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.SignatureInflationTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.SyntheticAccessTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.constants.NumberComplexityTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.constants.StringEncryptionTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.controlflow.ControlFlowMangleTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.controlflow.ControlFlowShuffleTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.ClassRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.FieldRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.MethodRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.ResourceRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.ParameterRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.ReflectRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.VariableRenameTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.LocalVariableRemoveTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.NopOperationRemoveTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.SourceStripperTransformer
import dev.sharkuscator.obfuscator.utilities.LoggerConfigurator
import org.clyze.jphantom.ClassMembers
import org.clyze.jphantom.hier.ClassHierarchies
import org.mapleir.DefaultInvocationResolver
import org.mapleir.app.client.SimpleApplicationContext
import org.mapleir.app.service.ApplicationClassSource
import org.mapleir.app.service.LibraryClassSource
import org.mapleir.asm.ClassNode
import org.mapleir.context.AnalysisContext
import org.mapleir.context.BasicAnalysisContext.BasicContextBuilder
import org.mapleir.deob.dataflow.LiveDataFlowAnalysisImpl
import org.mapleir.ir.algorithms.BoissinotDestructor
import org.mapleir.ir.algorithms.LocalsReallocator
import org.mapleir.ir.codegen.ControlFlowGraphDumper
import org.topdank.byteengineer.commons.asm.ASMFactory
import org.topdank.byteengineer.commons.asm.DefaultASMFactory
import org.topdank.byteengineer.commons.data.JarContents
import org.topdank.byteengineer.commons.data.JarInfo
import java.io.File
import java.io.IOException
import java.lang.invoke.MethodHandles
import java.nio.file.Path
import java.util.jar.JarFile
import kotlin.io.path.readText
import kotlin.properties.Delegates


class Sharkuscator(private val configurationFilePath: Path, private val inputJarFile: File, private val outputJarFile: File) {
    var isInputRecognizedAsMinecraftMod by Delegates.notNull<Boolean>()
    val registeredTransformers = mutableListOf(
        // obfuscates
        VariableRenameTransformer,
        ParameterRenameTransformer,
        MethodRenameTransformer,
        FieldRenameTransformer,
        ClassRenameTransformer,
        ResourceRenameTransformer,
        ReflectRenameTransformer,

//        ControlFlowFlatteningTransformer,
        ControlFlowMangleTransformer,
        ControlFlowShuffleTransformer,
        StringEncryptionTransformer,
//        NumberMaskingTransformer,
        NumberComplexityTransformer,
        SignatureInflationTransformer,
        SyntheticAccessTransformer,
        DynamicInvokeTransformer,
        NativeObfuscateTransformer,

        // shrinks
        LocalVariableRemoveTransformer,
        NopOperationRemoveTransformer,
        SourceStripperTransformer,
    )

    private lateinit var configuration: GsonConfiguration
    private lateinit var exclusions: ExclusionRule

    private lateinit var inputJarContents: JarContents<ClassNode>
    private lateinit var classSource: ApplicationClassSource
    private lateinit var hierarchyProvider: HierarchyProvider

    fun obfuscate() {
        LoggerConfigurator.disableExternalLogging()
        if (!inputJarFile.exists()) {
            ObfuscatorServices.sharkLogger.error("Input jar does not exist!")
            return
        }

        configuration = importConfiguration()
        exclusions = MixedExclusionRule(buildList {
            addAll(configuration.exclusions.map {
                StringExclusionRule(it.replace("**", ".*").replace("/", "\\/").toRegex())
            })
            add(AnnotationExclusionRule())
        })

        val phantomJarDownloader = createJarDownloader(inputJarFile, true)
        inputJarContents = phantomJarDownloader.jarContents
        isInputRecognizedAsMinecraftMod = inputJarContents.resourceContents.any { it.name == "mcmod.info" || it.name == "fabric.mod.json" }

        classSource = ApplicationClassSource(inputJarFile.getName().drop(4), inputJarContents.classContents)
        classSource.addLibraries(readLibrarySource(classSource, File(System.getProperty("java.home"), "lib/jce.jar")))
        classSource.addLibraries(readLibrarySource(classSource, File(System.getProperty("java.home"), "lib/rt.jar")))
        for (libraryFile in resolveLibraries()) {
            classSource.addLibraries(readLibrarySource(classSource, libraryFile))
        }
        classSource.addLibraries(LibraryClassSource(classSource, phantomJarDownloader.generatedClassContent))

        hierarchyProvider = DefaultHierarchyProvider(classSource)
        classSource.iterateWithLibraries().forEach { classNode ->
            hierarchyProvider.traverseHierarchy(classNode)
        }

        val obfuscationContext = createObfuscationContext(hierarchyProvider, createAnalysisContext())
        registeredTransformers.forEach { it.initialization(configuration) }
        registeredTransformers.sortBy { it.executionPriority() }

        ObfuscatorServices.mainEventBus.registerLambdaFactory("dev.sharkuscator") { lookupInMethod, klass ->
            lookupInMethod.invoke(null, klass, MethodHandles.lookup()) as MethodHandles.Lookup
        }

        for (transformer in registeredTransformers.filter { it.isEligibleForExecution() }) {
            ObfuscatorServices.mainEventBus.subscribe(transformer)
            dispatchTransformEvents(obfuscationContext)
            transformer.transformed = true
        }

        ObfuscatorServices.sharkLogger.info("Translating SSA IR to standard flavour")
        for ((methodNode, controlFlowGraph) in obfuscationContext.analysisContext.irCache.entries) {
            controlFlowGraph.verify()

            BoissinotDestructor.leaveSSA(controlFlowGraph)
            LocalsReallocator.realloc(controlFlowGraph)

            ControlFlowGraphDumper(controlFlowGraph, methodNode).dump()
        }

        ObfuscatorServices.sharkLogger.info("Recompiling Class...")
        ResolvingDumper(obfuscationContext).dump(outputJarFile)
        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.FinalizationEvent(obfuscationContext, inputJarFile, outputJarFile))
    }

    private fun dispatchTransformEvents(obfuscationContext: ObfuscationContext) {
        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.InitializationEvent(obfuscationContext, inputJarFile, outputJarFile))

        inputJarContents.resourceContents.namedMap().filter { !exclusions.excluded(it.key) }.forEach {
            ObfuscatorServices.mainEventBus.post(TransformerEvents.ResourceTransformEvent(obfuscationContext, it.value.name, it.value.data))
        }

        inputJarContents.classContents.namedMap().filter { !exclusions.excluded(it.value) && !it.value.isAutoGenerated() }.forEach { classContent ->
            ObfuscatorServices.mainEventBus.post(TransformerEvents.ClassTransformEvent(obfuscationContext, classContent.value))

            classContent.value.fields.filter { !exclusions.excluded(it) }.forEach {
                ObfuscatorServices.mainEventBus.post(TransformerEvents.FieldTransformEvent(obfuscationContext, it))
            }

            classContent.value.methods.filter { !exclusions.excluded(it) }.forEach {
                ObfuscatorServices.mainEventBus.post(TransformerEvents.MethodTransformEvent(obfuscationContext, it))
            }
        }

        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.PostTransformEvent(obfuscationContext, inputJarFile, outputJarFile))
    }

    private fun importConfiguration(): GsonConfiguration {
        try {
            ObfuscatorServices.sharkLogger.info("Importing configuration...")
            return ObfuscatorServices.prettyGson.fromJson(configurationFilePath.readText(), GsonConfiguration::class.java)
        } catch (exception: Exception) {
            exception.printStackTrace()
            return GsonConfiguration()
        }
    }

    private fun resolveLibraries(): List<File> {
        return configuration.libraries.flatMap { libraryPath ->
            val libraryFile = File(libraryPath)
            when {
                libraryFile.isDirectory -> libraryFile.listFiles()?.filter { it.isFile }?.toList() ?: emptyList()
                libraryFile.isFile -> listOf(libraryFile)
                else -> {
                    ObfuscatorServices.sharkLogger.warn("Library path '$libraryPath' is not a valid file or directory, skipping.")
                    emptyList()
                }
            }
        }
    }

    private fun readLibrarySource(classSource: ApplicationClassSource, libraryFile: File): LibraryClassSource {
        return LibraryClassSource(classSource, createJarDownloader(libraryFile, false).jarContents.classContents)
    }

    @Throws(IOException::class)
    private fun createJarDownloader(jarFile: File, usePhantomFactory: Boolean): PhantomJarDownloader {
        val asmFactory: ASMFactory<ClassNode> = if (usePhantomFactory) {
            createPhantomAsmFactory(jarFile)
        } else {
            DefaultASMFactory()
        }
        return PhantomJarDownloader(asmFactory, JarInfo(jarFile)).apply { download() }
    }

    @Throws(IOException::class)
    private fun createPhantomAsmFactory(jarFile: File): PhantomASMFactory {
        val classHierarchy = JarFile(jarFile).use { openedJarFile -> ClassHierarchies.fromJar(openedJarFile) }
        val classMembers = JarFile(jarFile).use { openedJarFile -> ClassMembers.fromJar(openedJarFile, classHierarchy) }
        return PhantomASMFactory(classHierarchy, classMembers)
    }

    private fun createAnalysisContext(): AnalysisContext {
        return BasicContextBuilder().apply {
            setDataFlowAnalysis(LiveDataFlowAnalysisImpl(ObfuscatorServices.flowGraphCache))
            setCache(ObfuscatorServices.flowGraphCache)

            setInvocationResolver(DefaultInvocationResolver(classSource))
            setApplicationContext(SimpleApplicationContext(classSource))
            setApplication(classSource)
        }.build()
    }

    private fun createObfuscationContext(hierarchyProvider: HierarchyProvider, analysisContext: AnalysisContext): ObfuscationContext {
        return ObfuscationContext(inputJarContents, classSource, hierarchyProvider, analysisContext, configuration, exclusions, isInputRecognizedAsMinecraftMod)
    }
}
