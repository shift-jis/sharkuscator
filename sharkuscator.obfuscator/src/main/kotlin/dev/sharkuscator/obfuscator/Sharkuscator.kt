package dev.sharkuscator.obfuscator

import dev.sharkuscator.commons.downloaders.DownloadedLibrary
import dev.sharkuscator.commons.downloaders.PhantomJarDownloader
import dev.sharkuscator.commons.extensions.isAutoGenerated
import dev.sharkuscator.commons.providers.ApplicationClassProvider
import dev.sharkuscator.commons.providers.LibraryClassProvider
import dev.sharkuscator.commons.serializers.PhantomBytecodeSerializer
import dev.sharkuscator.obfuscator.configuration.GsonConfiguration
import dev.sharkuscator.obfuscator.configuration.exclusions.AnnotationExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.ExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.MixedExclusionRule
import dev.sharkuscator.obfuscator.configuration.exclusions.StringExclusionRule
import dev.sharkuscator.obfuscator.events.ObfuscatorEvents
import dev.sharkuscator.obfuscator.events.TransformerEvents
import dev.sharkuscator.commons.providers.DefaultHierarchyProvider
import dev.sharkuscator.commons.providers.HierarchyProvider
import dev.sharkuscator.obfuscator.transformers.obfuscators.DynamicInvokeTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.NativeObfuscateTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.SignatureInflationTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.SyntheticAccessTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.constants.NumberComplexityTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.constants.StringEncryptionTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.controlflow.ControlFlowMangleTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.controlflow.ControlFlowShuffleTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.ClassRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.FieldRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.MethodRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.ResourceRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.ParameterRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.ReflectRenameTransformer
import dev.sharkuscator.obfuscator.transformers.obfuscators.renamers.miscellaneous.VariableRenameTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.KotlinMetadataRemoveTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.LocalVariableRemoveTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.NopOperationRemoveTransformer
import dev.sharkuscator.obfuscator.transformers.shrinkers.SourceStripperTransformer
import dev.sharkuscator.obfuscator.utilities.LoggerConfigurator
import dev.sharkuscator.obfuscator.utilities.ResolvingJarAssembler
import org.clyze.jphantom.ClassMembers
import org.clyze.jphantom.hier.ClassHierarchies
import java.io.File
import java.io.IOException
import java.lang.invoke.MethodHandles
import java.nio.file.Path
import java.util.jar.JarFile
import kotlin.io.path.readText
import kotlin.properties.Delegates


class Sharkuscator(private val configurationFilePath: Path, private val inputJarFile: File, private val outputJarFile: File) {
    var isRecognizedAsMinecraftMod by Delegates.notNull<Boolean>()
    val registeredTransformers = mutableListOf(
        // obfuscates
        VariableRenameTransformer,
        ParameterRenameTransformer,
        MethodRenameTransformer,
        FieldRenameTransformer,
        ClassRenameTransformer,
        ResourceRenameTransformer,
        ReflectRenameTransformer,

        ControlFlowMangleTransformer,
        ControlFlowShuffleTransformer,
        StringEncryptionTransformer,
        NumberComplexityTransformer,
        SignatureInflationTransformer,
        SyntheticAccessTransformer,
        DynamicInvokeTransformer,
        NativeObfuscateTransformer,

        // shrinks
        KotlinMetadataRemoveTransformer,
        LocalVariableRemoveTransformer,
        NopOperationRemoveTransformer,
        SourceStripperTransformer,
    )

    private val classNodeProvider = ApplicationClassProvider()
    private lateinit var downloadedLibrary: DownloadedLibrary
    private lateinit var hierarchyProvider: HierarchyProvider
    private lateinit var configuration: GsonConfiguration
    private lateinit var exclusions: ExclusionRule

    fun obfuscate() {
        LoggerConfigurator.disableExternalLogging()
        if (!inputJarFile.exists()) {
            ObfuscatorServices.sharkLogger.error("Input jar does not exist!")
            return
        }

        configuration = importConfiguration()
        exclusions = MixedExclusionRule(buildList {
            addAll(configuration.exclusions.map {
                StringExclusionRule(it.replace("**", ".*").replace("/", "\\/").toRegex())
            })
            add(AnnotationExclusionRule())
        })

        val bytecodeSerializer = createPhantomBytecodeSerializer(inputJarFile)
        downloadedLibrary = PhantomJarDownloader(bytecodeSerializer, inputJarFile).download()
        isRecognizedAsMinecraftMod = downloadedLibrary.resources.any { it.first == "mcmod.info" || it.first == "fabric.mod.json" }

        classNodeProvider.processApplication(downloadedLibrary)
//        classNodeProvider.includeLibraries(readLibrarySource(File(System.getProperty("java.home"), "jmods/java.base.jmod")))
        resolveLibraries().forEach { classNodeProvider.includeLibraries(readLibrarySource(it)) }

        hierarchyProvider = DefaultHierarchyProvider(classNodeProvider)
        classNodeProvider.iterateWithLibraries().forEach { classNode ->
            hierarchyProvider.traverseHierarchy(classNode)
        }

        val obfuscationContext = createObfuscationContext(hierarchyProvider)
        registeredTransformers.forEach { it.initialization(configuration) }
        registeredTransformers.sortBy { it.executionPriority() }

        ObfuscatorServices.mainEventBus.registerLambdaFactory("dev.sharkuscator") { lookupInMethod, klass ->
            lookupInMethod.invoke(null, klass, MethodHandles.lookup()) as MethodHandles.Lookup
        }

        for (transformer in registeredTransformers.filter { it.isEligibleForExecution() }) {
            ObfuscatorServices.mainEventBus.subscribe(transformer)
            dispatchTransformEvents(obfuscationContext)
            transformer.transformed = true
        }

        ObfuscatorServices.sharkLogger.info("Recompiling Class...")
        ResolvingJarAssembler(obfuscationContext, bytecodeSerializer).writeToJarFile(outputJarFile)
        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.FinalizationEvent(obfuscationContext, inputJarFile, outputJarFile))
    }

    private fun dispatchTransformEvents(obfuscationContext: ObfuscationContext) {
        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.InitializationEvent(obfuscationContext, inputJarFile, outputJarFile))

        downloadedLibrary.resources.filter { !exclusions.excluded(it.first) }.forEach {
            ObfuscatorServices.mainEventBus.post(TransformerEvents.ResourceTransformEvent(obfuscationContext, it.first, it.second))
        }

        downloadedLibrary.classNodes.filter { !exclusions.excluded(it) && !it.isAutoGenerated() }.forEach { classNode ->
            ObfuscatorServices.mainEventBus.post(TransformerEvents.ClassTransformEvent(obfuscationContext, classNode))

            classNode.fields.filter { !exclusions.excluded(it) }.forEach {
                ObfuscatorServices.mainEventBus.post(TransformerEvents.FieldTransformEvent(obfuscationContext, it))
            }

            classNode.methods.filter { !exclusions.excluded(it) }.forEach {
                ObfuscatorServices.mainEventBus.post(TransformerEvents.MethodTransformEvent(obfuscationContext, it))
            }
        }

        ObfuscatorServices.mainEventBus.post(ObfuscatorEvents.PostTransformEvent(obfuscationContext, inputJarFile, outputJarFile))
    }

    private fun importConfiguration(): GsonConfiguration {
        try {
            ObfuscatorServices.sharkLogger.info("Importing configuration...")
            return ObfuscatorServices.prettyGson.fromJson(configurationFilePath.readText(), GsonConfiguration::class.java)
        } catch (exception: Exception) {
            exception.printStackTrace()
            return GsonConfiguration()
        }
    }

    private fun resolveLibraries(): List<File> {
        return configuration.libraries.map { File(it) }.flatMap { file ->
            if (file.isDirectory) file.listFiles()?.filter { it.isFile }?.toList() ?: emptyList() else listOf(file)
        }
    }

    private fun readLibrarySource(jarFile: File): LibraryClassProvider {
        val downloadedLibrary = PhantomJarDownloader(createPhantomBytecodeSerializer(jarFile), jarFile).download()
        return LibraryClassProvider(downloadedLibrary.generatedClassNodes)
    }

    @Throws(IOException::class)
    private fun createPhantomBytecodeSerializer(jarFile: File): PhantomBytecodeSerializer {
        val classHierarchy = JarFile(jarFile).use { openedJarFile -> ClassHierarchies.fromJar(openedJarFile) }
        val classMembers = JarFile(jarFile).use { openedJarFile -> ClassMembers.fromJar(openedJarFile, classHierarchy) }
        return PhantomBytecodeSerializer(classNodeProvider, classHierarchy, classMembers)
    }

    private fun createObfuscationContext(hierarchyProvider: HierarchyProvider): ObfuscationContext {
        return ObfuscationContext(downloadedLibrary, classNodeProvider, hierarchyProvider, configuration, exclusions, isRecognizedAsMinecraftMod)
    }
}
