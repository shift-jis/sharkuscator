package dev.sharkuscator.commons.extensions

import dev.sharkuscator.commons.AssemblyHelper
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.FieldNode
import org.objectweb.asm.tree.InsnNode
import org.objectweb.asm.tree.MethodNode

fun ClassNode.getQualifiedName(): String = "${name}.class"

fun ClassNode.isAnonymousClass(): Boolean = name.contains("$")

fun ClassNode.isDeclaredAsInterface(): Boolean = (access and Opcodes.ACC_INTERFACE) != 0

fun ClassNode.isDeclaredAsAnnotation(): Boolean = (access and Opcodes.ACC_ANNOTATION) != 0

fun ClassNode.isDeclaredAsAbstract(): Boolean = (access and Opcodes.ACC_ABSTRACT) != 0

fun ClassNode.containsConstructor(): Boolean = methods.any { it.isConstructor() }

fun ClassNode.containsMainMethod(): Boolean = methods.any { it.hasMainSignature() }

fun ClassNode.isSpongeMixin(): Boolean = hasInVisibleAnnotation("Lorg/spongepowered/asm/mixin/Mixin;")

fun ClassNode.isAutoGenerated(): Boolean = hasVisibleAnnotation("LAutoGenerated;")

fun ClassNode.isNestedClass(): Boolean = outerClass != null && outerClass.isNotEmpty()

fun ClassNode.hasVisibleAnnotationContaining(descriptor: String): Boolean {
    return visibleAnnotations?.any { it.desc.contains(descriptor) } ?: false
}

fun ClassNode.hasVisibleAnnotation(descriptor: String): Boolean {
    return visibleAnnotations?.any { it.desc == descriptor } ?: false
}

fun ClassNode.hasInVisibleAnnotationContaining(descriptor: String): Boolean {
    return invisibleAnnotations?.any { it.desc.contains(descriptor) } ?: false
}

fun ClassNode.hasInVisibleAnnotation(descriptor: String): Boolean {
    return invisibleAnnotations?.any { it.desc == descriptor } ?: false
}

fun ClassNode.shouldSkipTransform(): Boolean {
    return isDeclaredAsAnnotation() || isDeclaredAsInterface() || isAutoGenerated() || isSpongeMixin() || isAnonymousClass()
}

fun ClassNode.resolveStaticInitializer(): MethodNode {
    return methods.find { it.isStaticInitializer() } ?: addNewStaticInitializer()
}

fun ClassNode.addNewStaticInitializer(): MethodNode {
    return addMethodNode(AssemblyHelper.createMethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V").apply {
        instructions = AssemblyHelper.buildInstructionList { add(InsnNode(Opcodes.RETURN)) }
    })
}

fun ClassNode.addMethodNode(methodNode: MethodNode): MethodNode {
    methods.add(methodNode)
    methodNode.classNode = this
    return methodNode
}

fun ClassNode.addFieldNode(fieldNode: FieldNode): FieldNode {
    fields.add(fieldNode)
    fieldNode.classNode = this
    return fieldNode
}
