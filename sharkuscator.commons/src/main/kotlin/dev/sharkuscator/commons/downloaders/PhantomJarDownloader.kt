package dev.sharkuscator.commons.downloaders

import ch.qos.logback.classic.Level
import com.google.common.io.ByteStreams
import dev.sharkuscator.commons.extensions.classNode
import dev.sharkuscator.commons.serializers.BytecodeSerializer
import dev.sharkuscator.commons.serializers.PhantomBytecodeSerializer
import org.clyze.jphantom.JPhantom
import org.clyze.jphantom.Options
import org.clyze.jphantom.Phantoms
import org.clyze.jphantom.access.ClassAccessStateMachine
import org.clyze.jphantom.access.FieldAccessStateMachine
import org.clyze.jphantom.access.MethodAccessStateMachine
import org.clyze.jphantom.constraints.Constraint
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.ClassNode
import java.io.File
import java.util.jar.JarFile

class PhantomJarDownloader(classNodeSerializer: BytecodeSerializer<ClassNode>, jarFile: File) : AbstractJarDownloader<ClassNode>(classNodeSerializer, JarFile(jarFile)) {
    val generatedClassNodes: MutableList<ClassNode> = mutableListOf()

    override fun download(): DownloadedLibrary {
        this@PhantomJarDownloader.jarFile.entries().iterator().forEach { jarEntry ->
            val byteArray = ByteStreams.toByteArray(this@PhantomJarDownloader.jarFile.getInputStream(jarEntry))
            if (jarEntry.name.endsWith(".class")) {
                downloadedClassNodes.add(bytecodeSerializer.deserialize(byteArray).also {
                    it.methods.forEach { methodNode -> methodNode.classNode = it }
                    it.fields.forEach { fieldNode -> fieldNode.classNode = it }
                })
            } else {
                downloadedResources.add(jarEntry.getName() to byteArray)
            }
        }

        if (bytecodeSerializer is PhantomBytecodeSerializer) {
            Options.V().setLogLevel(Level.OFF)
            Options.V().isSoftFail = true
            Options.V().javaVersion = 8

            val uniqueConstraintRepresentations: MutableSet<String> = HashSet()
            ClassAccessStateMachine.v().constraints.removeIf { constraint: Constraint ->
                val wasAlreadySeen = uniqueConstraintRepresentations.contains(constraint.toString())
                uniqueConstraintRepresentations.add(constraint.toString())
                wasAlreadySeen
            }

            val jPhantomInstance = JPhantom(hashMapOf(), bytecodeSerializer.classHierarchy, bytecodeSerializer.classMembers)
            jPhantomInstance.run()

            jPhantomInstance.generated.forEach { (_, byteArray) ->
                val classReader = ClassReader(decorateWithAutoGeneratedAnnotation(byteArray))
                generatedClassNodes.add(ClassNode().also { classReader.accept(it, ClassReader.SKIP_DEBUG or ClassReader.SKIP_FRAMES) })
            }

            MethodAccessStateMachine.refresh()
            FieldAccessStateMachine.refresh()
            ClassAccessStateMachine.refresh()
            Phantoms.refresh()
        }

        return DownloadedLibrary(downloadedClassNodes, generatedClassNodes, downloadedResources)
    }

    private fun decorateWithAutoGeneratedAnnotation(generated: ByteArray): ByteArray {
        val annotatedClassWriter = ClassWriter(ClassWriter.COMPUTE_FRAMES)
        val annotationAddingVisitor = object : ClassVisitor(Opcodes.ASM9, annotatedClassWriter) {
            override fun visitEnd() {
                val annotationVisitor = visitAnnotation("LAutoGenerated;", true)
                annotationVisitor.visit("msg", "Recaf/JPhantom automatically generated this class")
                annotationVisitor.visitEnd()
                super.visitEnd()
            }
        }

        ClassReader(generated).also { it.accept(annotationAddingVisitor, ClassReader.SKIP_DEBUG or ClassReader.SKIP_FRAMES) }
        return annotatedClassWriter.toByteArray()
    }
}
